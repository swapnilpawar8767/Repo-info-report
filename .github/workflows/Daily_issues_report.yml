name: Weekly GitHub Repo Report (Last 7 Days)

on:
  schedule:
    - cron: "30 2 * * *"  # Daily at 08:00 IST (2:30 AM UTC)
  workflow_dispatch:

permissions:
  contents: read
  issues: read

jobs:
  send-report:
    runs-on: ubuntu-latest
    steps:
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: pip install requests pytz

      - name: Generate and send report
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Use your TL's token
          REPORT_WEBHOOK_URL: ${{ vars.REPORT_WEBHOOK_URL }}  # Use same webhook variable as TL
        run: |
          python << 'EOF'
          import requests
          import os
          import datetime
          import pytz

          # Repos to report on
          repos = [
              "swapnilpawar8767/Repo-info-report"
          ]

          headers = {
              "Authorization": f"token {os.environ['GITHUB_TOKEN']}",
              "Accept": "application/vnd.github.v3+json"
          }

          IST = pytz.timezone('Asia/Kolkata')
          today_utc = datetime.datetime.utcnow().replace(tzinfo=datetime.timezone.utc)
          seven_days_ago_utc = today_utc - datetime.timedelta(days=7)

          report_date = datetime.date.today()
          separator = "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"

          message_parts = []
          message_parts.append(f"ðŸ“Š GitHub Repo Report - Last 7 Days (Up to {report_date})\n\n")

          for repo in repos:
              repo_header = f"\n{separator}\n\n{' ' * 15}**{repo.upper()}**\n\n{separator}\n"
              message_parts.append(repo_header)

              page = 1
              per_page = 100
              while True:
                  response = requests.get(
                      f"https://api.github.com/repos/{repo}/issues?state=all&per_page={per_page}&page={page}&sort=updated",
                      headers=headers,
                  )
                  issues = response.json()
                  if not issues:
                      break

                  for issue in issues:
                      if "pull_request" in issue:
                          continue

                      updated_at_raw = issue.get("updated_at", "")
                      try:
                          dt_utc = datetime.datetime.strptime(updated_at_raw, "%Y-%m-%dT%H:%M:%SZ")
                          dt_utc = dt_utc.replace(tzinfo=datetime.timezone.utc)
                      except Exception:
                          continue

                      # Only include issues updated in the last 7 days
                      if dt_utc < seven_days_ago_utc:
                          continue

                      title = issue.get("title", "")
                      issue_url = issue.get("html_url", "")
                      status = "ðŸ†• Open" if issue.get("state", "").lower() == "open" else "Closed"

                      dt_ist = dt_utc.astimezone(IST)
                      updated_at = dt_ist.strftime("%Y-%m-%d %H:%M:%S")

                      due_date = "-"
                      if issue.get("milestone") and issue["milestone"].get("due_on"):
                          due_date = issue["milestone"]["due_on"][:10]

                      last_comment = "No comments"
                      if issue.get("comments", 0) > 0:
                          comments_response = requests.get(issue["comments_url"], headers=headers)
                          comments = comments_response.json()
                          if comments:
                              last_comment = comments[-1].get("body", "").replace("\n", " ")
                              if len(last_comment) > 50:
                                  last_comment = last_comment[:47] + "..."

                      message_parts.append(f"ðŸ“Œ **[{title}]({issue_url})**  \n"
                                           f"**Last Comment** :: {last_comment}  \n"
                                           f"**Due Date**     :: {due_date}  \n"
                                           f"**Status**       :: {status}  \n"
                                           f"**Last Updated** :: {updated_at}  \n"
                                           f"{separator}\n")

                  if len(issues) < per_page:
                      break
                  page += 1

          final_message = "".join(message_parts)

          payload = {
              "text": final_message,
              "markdown": True
          }

          webhook_url = os.environ.get("REPORT_WEBHOOK_URL", "")
          if not webhook_url:
              print("Webhook URL not set, skipping send.")
          else:
              resp = requests.post(webhook_url, json=payload)
              if resp.status_code != 200:
                  print(f"Failed to post report: {resp.status_code} {resp.text}")
                  exit(1)
              print("âœ… Report sent to Teams successfully!")
          EOF
